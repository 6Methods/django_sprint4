# Что сделано в проекте

Здесь я описываю, что было реализовано в финальной версии проекта Блогикум.

## Кастомные страницы ошибок

Настроил обработчики для трех типов ошибок: 403 (CSRF), 404 (страница не найдена) и 500 (ошибка сервера). Шаблоны для них лежат в templates/pages/. Функции-обработчики написал в pages/views.py и подключил их в главном urls.py через переменные handler403, handler404 и handler500.

## Работа с пользователями

Подключил стандартные пути Django для аутентификации из django.contrib.auth.urls. Это дало страницы входа, выхода, смены пароля и восстановления доступа.

Создал все необходимые шаблоны в папке templates/registration/. Там есть формы для входа, регистрации, смены пароля и восстановления через email.

Добавил страницу регистрации по адресу auth/registration/ с формой для создания нового пользователя.

Сделал страницу профиля profile/<username>/, которая показывает информацию о пользователе и все его публикации. Если это твой профиль, то видны ссылки на редактирование профиля и смену пароля. Чужие профили можно только смотреть.

## Пагинация

На трех страницах настроил пагинацию по 10 постов: главная, профиль пользователя и страница категории. Использовал встроенную пагинацию Django через параметр paginate_by в ListView.

## Изображения к постам

Добавил в модель Post поле image с типом ImageField. Изображения загружаются в папку media/post_images/. Настроил MEDIA_URL и MEDIA_ROOT в settings.py и добавил обработку медиа-файлов в urls.py для режима разработки.

Изображения отображаются на всех страницах со списками постов и на детальной странице поста. В шаблонах проверяется наличие изображения через условие, и если оно есть, то показывается.

## Добавление публикаций

Создал страницу posts/create/ с формой для добавления новых постов. Доступна только авторизованным пользователям через LoginRequiredMixin.

В форме можно указать заголовок, текст, дату публикации, выбрать категорию и местоположение, загрузить изображение. После сохранения пользователь попадает на свой профиль.

Реализовал отложенные публикации. Если указать дату в будущем, пост станет виден всем только с этого момента. Но автор видит его сразу после создания.

## Редактирование публикаций

По адресу posts/<post_id>/edit/ можно редактировать пост. Доступ есть только у автора, это проверяется в методе dispatch. Если пытается зайти не автор, его перенаправляет на страницу просмотра поста.

Использую тот же шаблон blog/create.html, что и для создания. После редактирования пользователь попадает на страницу отредактированного поста.

## Комментарии

На странице поста под текстом публикации находится форма для добавления комментария. Ниже показываются все комментарии к этому посту. Комментировать могут только авторизованные пользователи.

Комментарии отсортированы от старых к новым, это задано в Meta модели Comment через ordering.

Каждый может редактировать и удалять свои комментарии. Проверка авторства реализована так же, как для постов.

На всех страницах со списками постов выводится счетчик комментариев. Для этого использую annotate с Count('comments') в queryset.

Адреса для работы с комментариями:

- Добавление: posts/<post_id>/comment/
- Редактирование: posts/<post_id>/edit_comment/<comment_id>/
- Удаление: posts/<post_id>/delete_comment/<comment_id>/

## Удаление

Реализовал удаление постов по адресу posts/<post_id>/delete/ и комментариев по адресу posts/<post_id>/delete_comment/<comment_id>/.

Перед удалением показывается страница подтверждения. Для постов использую тот же шаблон create.html, для комментариев - comment.html. В шаблонах есть логика для определения, создается объект, редактируется или удаляется.

Удалять можно только свои материалы, это проверяется через dispatch.

## Статичные страницы

Страницы "О проекте" и "Правила" переписал на class-based views. Использовал TemplateView, это самый простой вариант для статичных страниц. URL-адреса остались прежними.

## Email

Настроил файловый бэкенд для email через EMAIL_BACKEND в settings.py. Все "отправленные" письма сохраняются в папку sent_emails/. Эту папку добавил в .gitignore, чтобы не попадала в репозиторий.

Подключать настоящий почтовый сервер не стал, так как это учебный проект.

## Архитектура решения

Создал четыре модели в blog/models.py:

- Category для категорий постов
- Location для местоположений
- Post для публикаций
- Comment для комментариев

Сделал абстрактную модель PublishedModel с полями is_published и created_at, от нее наследуются Category, Location и Post.

Для views использовал mix из function-based и class-based views. Основные views это:

- IndexView, ProfileView, CategoryPostsView - ListView для списков
- PostDetailView - DetailView для отдельного поста
- PostCreateView, CommentCreateView - CreateView для создания
- PostUpdateView, CommentUpdateView, UserUpdateView - UpdateView для редактирования
- PostDeleteView, CommentDeleteView - DeleteView для удаления
- RegistrationView - CreateView для регистрации

Создал миксин PostQuerySetMixin для переиспользования логики получения отфильтрованных постов. В нем метод get_post_queryset, который возвращает queryset с нужными фильтрами и оптимизацией.

Формы находятся в blog/forms.py:

- PostForm для постов
- CommentForm для комментариев
- UserEditForm для редактирования профиля
- CustomUserCreationForm для регистрации

Для безопасности использую LoginRequiredMixin в views, где нужна авторизация. Проверку авторства делаю в методе dispatch, сравнивая request.user с автором объекта.

## Оптимизация запросов

В querysets применяю select_related для получения связанных объектов (автор, категория, местоположение) одним запросом вместо N+1.

Для подсчета комментариев использую annotate(comment_count=Count('comments')), чтобы не делать отдельные запросы для каждого поста.

Явно указываю сортировку через order_by('-pub_date'), так как при использовании annotate ordering из Meta модели может теряться.

## Тестирование

Все 25 тестов от Практикума проходят успешно. Тесты проверяют:

- Корректность моделей и их полей
- Правильность фильтрации контента
- Работу пагинации
- Отображение изображений
- Создание, редактирование и удаление постов и комментариев
- Страницы ошибок
- Работу с пользователями
- Настройки email
- Использование CBV для статичных страниц

## Соответствие стандартам

Код написан по PEP8. Проверял через flake8 с настройками из setup.cfg.

Использовал соглашения Django по именованию: модели в единственном числе с большой буквы, имена полей в snake_case, verbose_name на русском для админки.

Views и URL следуют REST-подобной логике: /posts/ для списка, /posts/<id>/ для просмотра, /posts/<id>/edit/ для редактирования.

## Что получилось

В итоге получился полнофункциональный блог с регистрацией пользователей, публикацией постов с изображениями, комментированием и управлением профилем. Проект готов к использованию и соответствует всем требованиям задания.
